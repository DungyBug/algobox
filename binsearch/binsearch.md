# Двоичный поиск
Двоичный поиск, или *бинпоиск*, применяется на **отсортированном**
массиве для эффективного нахождения элементов.

В интернете про него сказано слишком много, поэтому я ограничусь
лишь замерами производительности наивной реализации ( т.е. линейного поиска ) и бинпоиска.

Наивная реализация:

```cpp
#include <vector>
#include <stdint.h>

template <typename T>
int32_t linearSearch(const std::vector<T> &array, const T& searchingValue) {
    for(int32_t i = 0; i < array.size(); i++) {
        if(array[i] == searchingValue)
            return i;
    }

    return -1;
};
```
Таблица производительности в секундах:

| Размер массива | Среднее время | Мин.     | Макс.    |
|----------------|---------------|----------|----------|
| 10             | 0.000000      | 0.000000 | 0.000000 |
| 100            | 0.000000      | 0.000000 | 0.000000 |
| 1000           | 0.000001      | 0.000000 | 0.000002 |
| 10000          | 0.000012      | 0.000000 | 0.000024 |
| 100000         | 0.000119      | 0.000000 | 0.000239 |
| 1000000        | 0.001208      | 0.000000 | 0.002416 |
| 10000000       | 0.013141      | 0.000000 | 0.026282 |
| 100000000      | 0.122571      | 0.000000 | 0.245143 |

### Оптимизация

Реализация бинпоиска `search` в `binsearch.hpp` позволяет искать несколько типов
вхождений:
- ANY_ENTRANCE - первое попавшееся вхождение. Самый быстрый метод.
- LEFT_ENTRANCE - самое левое вхождение
- RIGHT_ENTRANCE - самое правое вхождение

Таблица производительности в **наносекундах** ( одна миллиардная секунды ):

*ANY_ENTRANCE*

| Размер массива | Среднее время | Мин.    | Макс.    |
|----------------|---------------|---------|----------|
| 10             | 55            | 30      | 201      |
| 100            | 51            | 29      | 103      |
| 1000           | 69            | 31      | 1139     |
| 10000          | 68            | 29      | 437      |
| 100000         | 77            | 27      | 3991     |
| 1000000        | 87            | 29      | 15600    |
| 10000000       | 97            | 27      | 12937    |
| 100000000      | 106           | 29      | 54833    |

*LEFT_ENTRANCE*

| Размер массива | Среднее время | Мин.    | Макс.    |
|----------------|---------------|---------|----------|
| 10             | 71            | 35      | 213      |
| 100            | 63            | 37      | 94       |
| 1000           | 71            | 44      | 447      |
| 10000          | 80            | 52      | 341      |
| 100000         | 90            | 60      | 11599    |
| 1000000        | 101           | 69      | 23489    |
| 10000000       | 110           | 77      | 47527    |
| 100000000      | 121           | 85      | 235193   |

*RIGHT_ENTRANCE*

| Размер массива | Среднее время | Мин.    | Макс.    |
|----------------|---------------|---------|----------|
| 10             | 68            | 27      | 194      |
| 100            | 58            | 36      | 116      |
| 1000           | 71            | 42      | 231      |
| 10000          | 76            | 52      | 465      |
| 100000         | 89            | 60      | 39738    |
| 1000000        | 96            | 68      | 34037    |
| 10000000       | 106           | 77      | 131553   |
| 100000000      | 115           | 86      | 169094   |

Измеряя в наносекундах, мы вышли на уровень тактов процессора, в котором
погрешность измерения может быть велика, т.к. на время могли повлиять другие процессы, выполнявшиеся в момент измерения.

Замеры для `LEFT_ENTRANCE` и `RIGHT_ENTRANCE` проводились на массиве, в котором было ~13% дубликатов значений.
Замеры для `ANY_ENTRANCE` проводились на полностью случайных значениях,
с ~0.4% дубликатами значений.

Также, в библиотеке есть `paramSearch`, которая выполняет поиск параметра в функции по возвращаемому значению. Важно, чтобы переданная функция монотонно возрастала ( т.е. при увеличении параметра значение функции либо не изменяется, либо тоже увеличивается ).

Пример использования:

```cpp
#include <iostream>
#include <stdint.h>

uint32_t square(uint32_t x) {
    return x * x;
}

auto result = paramSearch(0u, 20000000u, square, 18344089u);

std::cout << result.result << std::endl; // 4283
```