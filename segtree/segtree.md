# Дерево отрезков
Дерево отрезков, как правило, применяется для задач, в которых нужно эффективно вычислять какую-нибудь операцию над подотрезком массива.

Скажем, пусть у нас есть массив размера `n`, и нам поступают запросы двух типов:
- изменить элемент
- посчитать сумму на подотрезке [L; R)

Наивным образом это решается написанием дополнительной функции, которая суммирует значения на подотрезке:
```cpp
#include <vector>
#include <stdint.h>

template <typename T>
T calcSum(const std::vector<T> &values, uint32_t l, uint32_t r) {
    T sum = 0;

    for(uint32_t i = l; i < r; i++) {
        sum += values[i];
    }

    return sum;
};
```
Пояснения о том, как мы собираемся изменять значения в наивном способе, я думаю, не нужны.

Характеристики решения:

- `n` - количество значений в массиве
- `w` - размер подотрезка

| Характеристика      | O    |
|---------------------|------|
| Высчитывание суммы  | O(w) |
| Изменение элемента  | O(1) |
| Потребление памяти  | O(n) |

Таблица с временем исполнения представлена ниже:

| w         | секунды |
|-----------|---------|
| 1         | 0.00000 |
| 10        | 0.00000 |
| 100       | 0.00000 |
| 1000      | 0.00000 |
| 10000     | 0.00001 |
| 100000    | 0.00021 |
| 1000000   | 0.00208 |
| 10000000  | 0.02100 |
| 100000000 | 0.23409 |

В целом, для одноразового подсчёта такого алгоритма хватит, однако
если запросов будет не 1, а, скажем, 10000, то алгоритм явно будет работать
слишком долго.

### Оптимизация

Воспользуемся деревом отрезков.

Реализация дерева отрезков в `segtree.hpp` является абстрактной реализацией
ДО. Это позволяет создавать ДО, выполняющее любую операцию: от суммы до максимума.

Реализуем простейшее суммирующее ДО.

Для начала, нужно создать суммирующую функцию:

```cpp
template <typename T>
void summator(T& result, const T& left, const T& right) {
    result = left + right;
};
```

Она будет выполнять суммирование как отдельных элементов, так и сумм на отрезках ( она, фактически, и определяет, что будет искаться на подотрезке ).

Эту функцию теперь нужно передать в конструктор, вместе с размером массива:

```cpp
segtree_t<uint64_t> stree(256, summator);
```

ДО желательно заполнить значениями. Для этого есть метод `fillup`:

```cpp
std::vector<uint64_t> values(256);

for(uint64_t &value : values) {
    value = rand();
}

stree.fillup(values.data());
```

или `setValueWithoutUpdate`:

```cpp
for(uint32_t i = 0; i < 256; i++) {
    // setValueWithoutUpdate не обновляет диапазоны, поэтому отрабатывает быстрее
    stree.setValueWithoutUpdate(i, rand());
}

// Однако после вызова setValueWithoutUpdate() нужно вызывать updateSegments(),
// чтобы можно было спокойно использовать operate()
stree.updateSegments();
```

Ну и теперь, чтобы посчитать сумму на подотрезке, нам нужно вызвать метод `operate`:

```cpp
// Посчитает сумму в диапазоне [13; 44)
// Последний аргумент - это начальное значение ( в данном случае он не обязателен )
std::cout << stree.operate(13, 44, 0) << std::endl;
```

Чтобы изменить элемент, можно воспользоваться методом `setValue`.

Характеристики решения:

- `n` - количество значений в массиве
- `w` - размер подотрезка

| Характеристика      | O       |
|---------------------|---------|
| Высчитывание суммы  | O(logw) |
| Изменение элемента  | O(logn) |
| Потребление памяти  | O(n)    |

Таблица времени в наносекундах ( одна миллиардная секунды ) для высчитывания суммы:

| s\w        | 1    | 10   | 100  | 1000 | 10000 | 100000 | 1000000 | 10000000 |
|------------|------|------|------|------|-------|--------|---------|----------|
| 10         | 36   | 77   |      |      |       |        |         |          |
| 100        | 22   | 48   | 169  |      |       |        |         |          |
| 1000       | 21   | 32   | 53   | 241  |       |        |         |          |
| 10000      | 52   | 78   | 44   | 91   | 305   |        |         |          |
| 100000     | 21   | 31   | 44   | 89   | 101   | 184    |         |          |
| 1000000    | 21   | 31   | 45   | 88   | 102   | 119    | 228     |          |
| 10000000   | 21   | 31   | 44   | 88   | 103   | 119    | 134     | 255      |  
| 100000000  | 21   | 31   | 44   | 90   | 103   | 119    | 135     | 147      |

В таблице хорошо видна логарифмическая зависимость от размера окна.

*Отмечу, что наносекунды - это уже уровень тактов процессора, поэтому из таблицы
никаких выводов, кроме как о сложности алгоритма, делать не стоит.*