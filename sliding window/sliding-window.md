# Скользящее окно
Задачи со скользящим окном - это задачи, где вам даётся на вход массив, возможно длина окна, и вы, двигая это окно шаг за шагом, делаете какую-то простейшую операцию на этом окне.

Само окно - это отрезок массива с i-ого элемента по (i + w)-ый элемент, где `w` - размер окна. Двигая окно вперёд, мы инкрементируем `i`.

Возьмём массив:
`[12, 6, -14, 4, 29, 9, -2, 5, 0, -32, 44]`.
Пусть у нас есть скользящее окно длины 4 и нам нужно находить минимум в этом скользящем окне. Ниже перечисленны окна для различных индексов массива:
```
0:  12  - [12, 6, -14, 4] 
1:  6   - [6, -14, 4, 29]
2: -14  - [-14, 4, 29, 9]
3:  4   - [4, 29, 9, -2]
4:  29  - [29, 9, -2, 5]
5:  9   - [9, -2, 5, 0]
6: -2   - [-2, 5, 0, -32]
7:  5   - [5, 0, -32, 44]
8:  0   - [0, -32, 44]
9: -32  - [-32, 44]
10: 44  - [44]
```
*Последние 4 я не буду рассматривать, т.к. там окна имеют длину меньшую 4*

Найдём минимумы для окон:
```
 0   1   2   3   4   5   6   7  
-14 -14 -14 -2  -2  -2  -32 -32
```

Теперь, реализуем минимум в скользящем окне самым наивным способом:
```cpp
#include <vector>
#include <stdint.h>

template <typename T>
std::vector<T> minimumForSlidingWindowCorrect(
        const std::vector<T> &array,
        uint32_t slidingWindowWidth)
{
    // Some tasks require handling window width bigger than array size,
    // but in typical task about sliding window this can be omitted out.
    if(slidingWindowWidth >= array.size()) {
        std::vector<T> minimums(1);

        T min = array[0];

        for(const T& value : array) {
            if(value < min)
                min = value;
        }

        minimums[0] = min;

        return minimums;
    }
    
    // slidingWindowWidth + 1 omits last windows with size smaller
    // than slidingWindowWidth
    std::vector<T> minimums(array.size() - slidingWindowWidth + 1);

    for(uint32_t i = 0; i < array.size() - slidingWindowWidth + 1; i++) {
        T min = array[i];

        for(uint32_t j = i; j < i + slidingWindowWidth; j++) {
            if(array[j] < min)
                min = array[j];
        }

        minimums[i] = min;
    }

    return minimums;
}
```

Характеристики такой реализации представлены ниже:

| Сложность алгоритма | O(nw) |
|---------------------|-------|
| Потребление памяти  | O(1)  |

Также таблица с временем исполнения, где по вертикали изменяется количество элементов в массиве, а по горизонтали - размер окна:

| n\w      | 1      | 10     | 100    | 1000   | 10000   |
|----------|--------|--------|--------|--------|---------|
| 100      | 0.000s | 0.000s | 0.000s | 0.000s | 0.000s  |
| 1000     | 0.000s | 0.000s | 0.000s | 0.000s | 0.000s  |
| 10000    | 0.000s | 0.000s | 0.000s | 0.000s | 0.004s  |
| 100000   | 0.000s | 0.000s | 0.004s | 0.045s | 0.408s  |
| 1000000  | 0.004s | 0.006s | 0.044s | 0.456s | 4.484s  |
| 10000000 | 0.041s | 0.070s | 0.468s | 4.508s | 45.223s |

Прекрасно видно линейную зависимость времени от размера окна.

### Оптимизированный алгоритм

Алгоритм, реализованный в `minimum.hpp` имеет следующие характеристики:

| Сложность алгоритма | O(n) |
|---------------------|------|
| Потребление памяти  | O(w) |

Также таблица с временем исполнения
| n\w      | 1      | 10     | 100    | 1000   | 10000  |
|----------|--------|--------|--------|--------|--------|
| 100      | 0.000s | 0.000s | 0.000s | 0.000s | 0.000s |
| 1000     | 0.000s | 0.000s | 0.000s | 0.000s | 0.000s |
| 10000    | 0.000s | 0.000s | 0.000s | 0.000s | 0.000s |
| 100000   | 0.001s | 0.001s | 0.001s | 0.001s | 0.001s |
| 1000000  | 0.006s | 0.012s | 0.011s | 0.011s | 0.011s |
| 10000000 | 0.059s | 0.139s | 0.135s | 0.135s | 0.134s |

Хорошо видна линейная сложность, практически не зависящая от размера окна.