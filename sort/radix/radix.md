# Поразрядная сортировка
Один из алгоритмов сортировки, применяемый для сортировки чисел или элементов, из которых можно сделать числовой ключ.

Характеристика алгоритма приведены ниже:
| Характеристика | O     |
|----------------|-------|
| Сложность      | O(nw) |
| Память         | O(n)  |

где
- n - размер массива
- w - количество проходов ( в данной реализации это количество байт в ключе )

Простой пример использования `radixSort`:
```cpp
#include <random>
#include "radix.hpp"

// Функция-конвертер, которая принимает на вход элемент и записывает
// в `key` его числовой ключ ( в данном случае это сам элемент )
void u32toKey(uint32_t& element, void** key, uint32_t *keylen) {
    (*key) = (void*)&element;
    (*keylen) = sizeof(uint32_t);
}

uint32_t testArray[1000];
uint32_t outArray[1000];

for(uint32_t &value : testArray) {
    value = rand() & 0xff;
}

// Последний аргумент ( false ) говорит функции, чтобы ключи, созданные
// u32toKey не освобождались из памяти. Этот параметр нужен, если
// функция-конвертер выделяет новую память, что может быть нужно для 
// более сложных типов данных
radixSort(testArray, testArray + size, outArray, u32toKey, false);

// теперь outArray хранит отсортированную копию testArray
```

Также, для сортировки массива на месте ( как у `std::sort` ) можно воспользоваться функцией `radixSortInPlace`:

```cpp
radixSortInPlace(testArray, testArray + size, u32toKey, false);
// теперь testArray отсортирован
```

Функции можно также задать сортировку не по байтам, а по 2 байтам сразу:
```cpp
radixSort<2>(testArray, testArray + size, outArray, u32toKey, false);
```

Однако, на маленьких значениях скорость от этого может пострадать.

### Статистика
На `uint32_t` поразрядная сортировка показывает следующие результаты:
| Размер массива   | radixSort | std::sort |
|------------------|-----------|-----------|
| 10               | 0.000001  | 0.000000  |
| 100              | 0.000002  | 0.000005  |
| 1000             | 0.000012  | 0.000082  |
| 10000            | 0.000132  | 0.001062  |
| 100000           | 0.001502  | 0.012800  |
| 1000000          | 0.029790  | 0.150556  |
| 10000000         | 2.157345  | 1.722028  |

На небольших размерах `radixSort` быстрее `std::sort`, что не удивительно, ведь для данного случая `w = 4`, что фактически
делает `radixSort` линейным алгоритмом, в то время как `std::sort` имеет сложность `nlogn`.
